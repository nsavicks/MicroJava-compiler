package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

    public int error_sync_size()
    {
        return 1;
    }

    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

// Terminals

terminal PROGRAM, BREAK, CLASS, ABSTRACT, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXT, CONTINUE, PLUS, SUB, MUL, DIV, MOD, EQ, NEQ, GE, GEQ, LE, LEQ, AND, OR, ASSIGN, INC, DEC, SEMI, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE;
terminal Boolean BOOL;
terminal Integer NUMBER;
terminal String IDENT;
terminal Character CHAR;

// Non Terminals


nonterminal Mulop, Addop, Relop, Assignop;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;

nonterminal ActParsSingle;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Term;

nonterminal SubSingle;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr;

nonterminal CondFact, CondTermItem, CondTermList, CondTerm, ConditionList, ConditionSingle, ForConditionSingle, Condition;

nonterminal ActParsList, ActPars;

nonterminal DesignatorAssignItem, DesignatorStatement, DesignatorStatementSingle;

nonterminal ElseStatementSingle, ExprSingle, CommaNumConstSingle, StatementList, Statement;

nonterminal SquareSingle, TypeIdentSingle, TypeIdentList, FormPars;
nonterminal RetType, FormParsSingle, AbstractMethodDecl, VarDeclList, MethodDecl, ExtendsSingle, AbstractMethodDeclItem, AbstractMethodDeclList, AbstractClassMethodDeclSingle, AbstractClassDecl, MethodDeclList;
nonterminal VarType, VarIdentList, VarIdentSingle, VarDecl, ConstDeclListItem, ConstDeclList, ConstType, ConstDecl, Declaration, DeclarationList;


nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

nonterminal rs.etf.pp1.symboltable.concepts.Struct ConstLiteral;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ClassDeclSignature;

nonterminal ClassMethodDeclSingle, ClassDeclIdent, ClassDecl;

precedence left ELSE;

// Smene

Program ::= (Program) ProgName DeclarationList LBRACE MethodDeclList RBRACE;

ProgName ::= (ProgName) PROGRAM IDENT:progName;

DeclarationList ::= (DeclarationListNode) DeclarationList Declaration
                    |
                    (NoDeclarationList) /* epsilon */;

Declaration ::= (ConstDeclaration) ConstDecl
                |
                (VarDeclaration) VarDecl
                |
                (AbstractClassDeclaration) AbstractClassDecl
                |
                (ClassDeclaration) ClassDecl;

ConstDecl ::= (ConstDecl) ConstType ConstDeclList SEMI;

ConstType ::= (ConstType) CONST Type;

ConstDeclList ::= (ConstDeclListNode) ConstDeclList COMMA ConstDeclListItem
                    |
                    (ConstDeclListSingle) ConstDeclListItem;

ConstDeclListItem ::= (ConstDeclListItem) IDENT:constName ASSIGN ConstLiteral;

ConstLiteral ::= (ConstLiteralNum) NUMBER:value
                |
                (ConstLiteralChar) CHAR:value
                |
                (ConstLiteralBool) BOOL:value
                ;

VarDecl ::= (VarDeclNode) VarType VarIdentList SEMI
            |
            (ErrorVarDecl) error SEMI:l
            {: parser.report_error("Izvrsen oporavak u liniji "+lleft,null); :};

VarType ::= (VarType) Type;

VarIdentList ::= (VarIdentListNode) VarIdentList COMMA VarIdentSingle
            |
            (VarIdentListSingle) VarIdentSingle;

VarIdentSingle ::= (VarIdentSingleNode) IDENT:varName SquareSingle
                |
                (ErrorVarIdentSingle) error:l
                {: parser.report_error("Izvrsen oporavak u liniji "+lleft,null); :};

ClassDecl ::= (ClassDecl) ClassDeclSignature LBRACE VarDeclList ClassMethodDeclSingle RBRACE;

ClassDeclSignature ::= (ClassDeclSignature) ClassDeclIdent ExtendsSingle;

ClassMethodDeclSingle ::= (ClassMethodDeclSingleNode) LBRACE MethodDeclList RBRACE
                            |
                            (NoClassMethodDeclSingle) /* epsilon */;

MethodDeclList ::= (MethodDeclListNode) MethodDeclList MethodDecl
                    |
                    (NoMethodDeclList) /* epsilon */;

AbstractClassDecl ::= (AbstractClassDecl) ABSTRACT ClassDeclIdent ExtendsSingle LBRACE VarDeclList AbstractClassMethodDeclSingle RBRACE;

AbstractClassMethodDeclSingle ::= (AbstractClassMethodDeclSingleNode) LBRACE AbstractMethodDeclList RBRACE
                                   |
                                   (NoAbstractClassMethodSingle) /* epsilon */;

AbstractMethodDeclList ::= (AbstractMethodDeclListNode) AbstractMethodDeclList AbstractMethodDeclItem
                        |
                        (NoAbstractMethodDeclList) /* epsilon */;

AbstractMethodDeclItem ::= (MethodDeclItemNode) MethodDecl
                            |
                            (AbstractMethodDeclItemNode) AbstractMethodDecl;

ClassDeclIdent ::= (ClassDeclIdentNode) CLASS IDENT:className
                    |
                    (ErrorClassDeclIdent) error:l
                    {: parser.report_error("Izvrsen oporavak u liniji "+lleft,null); :};

ExtendsSingle ::= (ExtendsSingleNode) EXT Type
                    |
                    (NoExtendsSingle) /* epsilon */
                    |
                    (ErrorExtendsSingle) EXT error:l
                    {: parser.report_error("Izvrsen oporavak u liniji "+lleft,null); :};

MethodDecl ::= (MethodDecl) RetType IDENT LPAREN FormParsSingle RPAREN VarDeclList LBRACE StatementList RBRACE;

VarDeclList ::= (VarDeclListNode) VarDeclList VarDecl
                |
                (NoVarDeclList) /* epsilon */;

AbstractMethodDecl ::= (AbstractMethodDeclNode) ABSTRACT RetType IDENT LPAREN FormParsSingle RPAREN SEMI
                        |
                        (ErrorAbstractMethodDecl) error:l SEMI
                        {: parser.report_error("Izvrsen oporavak u liniji "+lleft,null); :};

FormParsSingle ::= (FormParsSingleNode) FormPars
                    |
                    (NoFormParsSingle) /* epsilon */;

RetType ::= (RetTypeNode) Type
            |
            (RetTypeVoid) VOID;

FormPars ::= (FormPars) TypeIdentList;

TypeIdentList ::= (TypeIdentListNode) TypeIdentList COMMA TypeIdentSingle
                    |
                    (SingleTypeIdentList) TypeIdentSingle;

TypeIdentSingle ::= (TypeIdentSingleNode) Type IDENT SquareSingle
                    |
                    (ErrorTypeIdentSingle) error:l
                    {: parser.report_error("Izvrsen oporavak u liniji "+lleft,null); :};

SquareSingle ::= (SquareSingleNode) LSQUARE RSQUARE
                |
                (NoSquareSingle) /* epsilon */;

Type ::= (Type) IDENT:typeName;

Statement ::= (StatementDesignator) DesignatorStatement SEMI
            |
            (StatementIf) IF LPAREN Condition RPAREN Statement ElseStatementSingle
            |
            (StatementFor) FOR LPAREN DesignatorStatementSingle SEMI ForConditionSingle DesignatorStatementSingle RPAREN Statement
            |
            (StatementBreak) BREAK SEMI
            |
            (StatementContinue) CONTINUE SEMI
            |
            (StatementReturn) RETURN ExprSingle SEMI
            |
            (StatementRead) READ LPAREN Designator RPAREN SEMI
            |
            (StatementPrint) PRINT LPAREN Expr CommaNumConstSingle RPAREN SEMI
            |
            (StatementStatementList) LBRACE StatementList RBRACE;

ForConditionSingle ::= (ForConditionSingleNode) ConditionSingle SEMI
                        |
                        (ErrorForConditionSingleNode) error SEMI:l
                        {: parser.report_error("Izvrsen oporavak u liniji "+lleft,null); :};

ConditionSingle ::= (ConditionSingleNode) Condition
                    |
                    (NoConditionSingle) /* epsilon */;

StatementList ::= (StatementListNode) StatementList Statement
                    |
                    (NoStatementList) /* epsilon */;

CommaNumConstSingle ::= (CommaNumConstSingleNode) COMMA NUMBER
                        |
                        (NoCommaNumConstSingle) /* epsilon */;

ExprSingle ::= (ExprSingleNode) Expr
                |
                (NoExprSingle) /* epsilon */;

ElseStatementSingle ::= (ElseStatementSingleNode) ELSE Statement
                        |
                        (NoElseStatementSingle) /* epsilon */;

DesignatorStatementSingle ::= (DesignatorStatementSingleNode) DesignatorStatement
                            |
                            (NoDesignatorStatementSingle) /* epsilon */;

DesignatorStatement ::= (DesignatorStatementFunc) Designator LPAREN ActParsSingle RPAREN
                        |
                        (DesignatorStatementInc) Designator INC
                        |
                        (DesignatorStatementDec) Designator DEC
                        |
                        (DesignatorStatementAssignNode) DesignatorAssignItem;

DesignatorAssignItem ::= (DesignatorAssignItemNode) Designator Assignop Expr
                        |
                        (ErrorDesignatorAssignItem) error:l
                        {: parser.report_error("Izvrsen oporavak u liniji "+lleft,null); :};

ActPars ::= (ActPars) Expr ActParsList;

ActParsList ::= (ActParsListNode) ActParsList COMMA Expr
                |
                (NoActParsList) /* epsilon */;

Condition ::= (Condition) CondTerm ConditionList;

ConditionList ::= (ConditionListNode) ConditionList OR CondTerm
                |
                (NoConditionList) /* epsilon */;

CondTerm ::= (CondTerm) CondFact CondTermList;

CondTermList ::= (CondTermListNode) CondTermList CondTermItem
                |
                (NoCondTermList) /* epsilon */;

CondTermItem ::= (CondTermItem) AND CondFact;

CondFact ::= (CondFactExpr) Expr
            |
            (CondFactRelop) Expr Relop Expr;

Expr ::= (ExprTerm) SubSingle Term
        |
        (ExprAdd) Expr Addop Term;

SubSingle ::= (SubSingleNode) SUB
            |
            (NoSubSingle) /* epsilon */;

Term ::= (TermFactor) Factor
        |
        (TermMul) Term Mulop Factor;

Factor ::= (FactorVariable) Designator
            |
            (FactorFuncCall) Designator LPAREN ActParsSingle RPAREN
            |
            (FactorConstant) ConstLiteral
            |
            (FactorNewArray) NEW Type LSQUARE Expr RSQUARE
            |
            (FactorNewClass) NEW Type
            |
            (FactorExpr) LPAREN Expr RPAREN;

ActParsSingle ::= (ActParsSingleNode) ActPars
            |
            (NoActParsSingle) /* epsilon */;

Designator ::= (DesignatorIdent) IDENT:name
                |
                (DesignatorDot) Designator DOT IDENT:classMember
                |
                (DesignatorArray) Designator LSQUARE Expr RSQUARE;


Assignop ::= (Assignop) ASSIGN;

Relop ::= (Equalop) EQ
        |
        (NotEqualop) NEQ
        |
        (Greaterop) GE
        |
        (GreaterEqualop) GEQ
        |
        (Lesserop) LE
        |
        (LesserEqualop) LEQ;

Addop ::= (Addop) PLUS
        |
        (Subop) SUB;

Mulop ::= (Mulop) MUL
        |
        (Divop) DIV
        |
        (Modop) MOD;
